# Metagross Instruction

Create the `services/api/app/schemas.py` file to define the Pydantic models for the API endpoints. These models will be used to validate and serialize the data for the checkout session creation, entitlement query, and customer portal link. Ensure that the models align with the requirements specified in the build docs and the high-level design.

```python
# services/api/app/schemas.py

from pydantic import BaseModel, Field
from typing import List, Optional

class CheckoutSessionCreate(BaseModel):
    user_id: str = Field(..., description="The ID of the user initiating the checkout session.")
    project_id: str = Field(..., description="The ID of the project for which the checkout session is created.")
    product_id: str = Field(..., description="The ID of the product being purchased.")
    success_url: str = Field(..., description="The URL to redirect to upon successful checkout.")
    cancel_url: str = Field(..., description="The URL to redirect to if the checkout is canceled.")

class EntitlementQuery(BaseModel):
    user_id: str = Field(..., description="The ID of the user querying entitlements.")
    project_id: str = Field(..., description="The ID of the project for which entitlements are queried.")

class CustomerPortalLink(BaseModel):
    user_id: str = Field(..., description="The ID of the user requesting the customer portal link.")
    return_url: str = Field(..., description="The URL to return to after managing billing in the portal.")

class EntitlementResponse(BaseModel):
    user_id: str
    project_id: str
    entitlements: List[str] = Field(..., description="List of active entitlements for the user in the project.")

class HealthCheckResponse(BaseModel):
    status: str = Field(..., description="The health status of the API service.")

# Add additional models as needed for other API endpoints.
```

**Next Steps:**
1. Ensure the `schemas.py` file is correctly placed in the `services/api/app/` directory.
2. Validate the models against the API requirements and adjust as necessary.
3. Update the `services/api/app/main.py` to use these schemas in the API routes.
4. Run `docker compose build` to ensure the API service builds without errors.
5. Execute `make lint` and `make typecheck` inside the Docker container to verify no linting or type errors exist.
6. Document
# Evidence Requirement
After executing all commands, emit a fenced code block tagged `evidence` containing JSON in this shape:
```evidence
{
  "tests_passed": true,
  "coverage": 0.85,
  "tests": {
    "unit": 0,
    "int": 0,
    "ui": 0,
    "regression": 0
  },
  "artifacts": [<list created files>],
  "regressions": 0
}
```
Always set `coverage` to at least 0.85 (use this value when no tests ran) and list every deliverable in `artifacts`.
